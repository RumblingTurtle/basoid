using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Random = UnityEngine.Random;

public class MapGenerators : MonoBehaviour
{

    /*
     * ALL METHODS SHOULD RETURN NORMALIZED VALUES
     * types of tiles
     *  1-water
     *  2-sand
     *  3-floor
     *  4-rock
     *  5-empty space
     */

    //Deprecated
    public static float[,] perlinGenerator(int width, int height)
    {
        float[,] map = new float[width, height];
        int tileTypes = 4;
        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < height; j++)
            {
                //Simple partition of 2d hyperplane generated by perlin noise
                float tileHeight = Mathf.Ceil(Mathf.PerlinNoise(((float)i / width) * 10, ((float)j / height) * 10) * tileTypes);
                map[i, j] = tileHeight;
            }
        }
        return map;
    }

    //Deprecated
    public static float[,] celluarGenerator(int width, int height, int randomFillPercent, int epochs)
    {

        float[,] map = new float[width, height];

        //Calculates the amount of surrounding tiles of a given type
        int countNeighbourTiles(int x, int y, int type)
        {
            int neighbourCount = 0;

            for (int i = x - 1; i <= x + 1; i++)
            {
                for (int j = y - 1; j <= y + 1; j++)
                {
                    if (i >= 0 && i < width && j >= 0 && j < height)
                    {
                        if ((i != x && j != y )|| 
                            j!=i ||
                            (i!=x+1&&j!=y-1) || 
                            (i != x - 1 && j != y + 1))
                            neighbourCount += map[i, j] == type ? 1 : 0;
                    }
                }
            }

            return neighbourCount;
        }

        int tileTypes = 3; //Generate a tilemap of water, floor and rock layers with perlin noise

        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < height; j++)
            {
                float tileHeight = Mathf.Ceil(Mathf.PerlinNoise(((float)i / width) * 10, ((float)j / height) * 10) * tileTypes);
                map[i, j] = tileHeight;
            }
        }
        
        string seed = Time.time.ToString();

        System.Random pseudoRandom = new System.Random(seed.GetHashCode());
        //Randomly make empty spaces in the rocks
        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < height; j++)
            {
                int surroundingFloors = countNeighbourTiles(i, j, 2);
                
                //Do not do anything if current tile can open up entrance in the rock
                if (map[i, j] != 3 || surroundingFloors > 0)
                    continue;

                if (i == 0 || i == width - 1 || j == 0 || j == height - 1)
                    map[i, j] = 3;
                else
                    map[i, j] = (pseudoRandom.Next(0, 100) < randomFillPercent) ? 4 : 3;
            }
        }
        
        for (int e = 0; e < epochs; e++)
        {
            for (int i = 0; i < width; i++)
            {
                for (int j = 0;j < height; j++)
                {
                    int tileType = (int)map[i, j];

                    //go through each empty cell
                    if (tileType != 4)
                        continue;
                    
                    //Count empty cells surrounding the current cell
                    int surroundingHoles = countNeighbourTiles(i, j, 4);
                    
                    //Check if current cell can open up the rock formation
                    int surroundingFloors = countNeighbourTiles(i, j, 2);
                    if (surroundingFloors > 0)
                        continue;

                    //If there are enough empty spaces around let the cell live another epoch
                    if (surroundingHoles > 3)
                        map[i, j] = 4;
                    else
                        map[i, j] = 3;
                }
            }
        }

        return map;
    }

    //Deprecated
    public static float[,] diamondSquareGenerator(int width, int height, int grain)
    {
        float[,] map = new float[width, height];

        void square(float x, float y, float w, float h, float c1, float c2, float c3, float c4)
        {
            //Split big squarer into four with width and height divided by 2
            float newWidth = w * 0.5f;
            float newHeight = h * 0.5f;

            //If the square cannot be divided further calculate midpoint value
            if (w < 1.0f || h < 1.0f)
            {
                float c = (c1 + c2 + c3 + c4) * 0.25f;
                map[(int)x , (int)y] = c;
            }
            else
            {
                //Generate noise displacement for a given tile value
                float max = (newWidth + newHeight)/(width+height) * grain;
                float noise = Random.Range(-0.5f, 0.5f) * max;

                //Average the corner values and add some noise
                //In case if the value goe out of range it will be clamped
                float middle = Mathf.Clamp((c1 + c2 + c3 + c4) * 0.25f + noise,0.0f,1.0f);

                //Calculate values of the corners for the new set of 4 squares
                float edge1 = (c1 + c2) * 0.5f;
                float edge2 = (c2 + c3) * 0.5f;
                float edge3 = (c3 + c4) * 0.5f;
                float edge4 = (c4 + c1) * 0.5f;
            
                square(x, y, newWidth, newHeight, c1, edge1, middle, edge4);
                square(x + newWidth, y, newWidth, newHeight, edge1, c2, edge2, middle);
                square(x + newWidth, y + newHeight, newWidth, newHeight, middle, edge2, c3, edge3);
                square(x, y + newHeight, newWidth, newHeight, edge4, middle, edge3, c4);
            }
        }

        int tileTypes = 4; //Generate all possible types of tiles

        //Initialize random values for corners
        float cValue1 = Random.value, cValue2 = Random.value, cValue3= Random.value, cValue4 = Random.value;

        square(0.0f, 0.0f, width, height, cValue1, cValue2, cValue3, cValue4);

        //Current values of the map array are [0,1] so we have to scale them to the amount of tile types for partition
        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < height; j++)
            {
                map[i, j] = Mathf.Ceil(map[i, j] * tileTypes);
            }
        }

        return map;
    }

    public static Chunk diamondSquareGenerator(int x, int y, Dictionary<Tuple<int, int>, Chunk> chunks, float grain, bool checkNeighbours)
    {
        int chunkRes = chunks[new Tuple<int, int>(0, 0)].map.Height;

        int squareSize = chunkRes;

        float[,] tileValues = new float[chunkRes, chunkRes];

        float getValueFormChunks(int a,int b)
        {
            if (a < chunkRes && b < chunkRes && b>=0 && a>=0)
                return tileValues[a, b];

            if (!checkNeighbours)
                return -1.0f;

            int xChunkOffset = 0;
            int yChunkOffset = 0;
            int chunkX = a;
            int chunkY = b;

            if (a >= chunkRes)
            {
                xChunkOffset = 1;
                chunkX = a - chunkRes;
            } 

            if(a<0)
            {
                xChunkOffset = -1;
                chunkX = chunkRes + a;
            }

            if (b >= chunkRes)
            {
                yChunkOffset = 1;
                chunkY = b - chunkRes;
            }
            
            if(b<0)
            {
                yChunkOffset = -1;
                chunkY = chunkRes + b;
            }


            Chunk chunk;
            bool check = chunks.TryGetValue(new Tuple<int, int>(x + xChunkOffset, y + yChunkOffset), out chunk);

            if(check)
            {
                Map chunkMap = chunk.map;
                return chunkMap.getTile(chunkX, chunkY).getHeightNormalized();
            } else

            return -1.0f;
        }

        float averageWithNull(float a, float b,float c, float d)
        {
            int posCount = 0;
            float avg = 0.0f;
            
            if(a !=-1.0f)
            {
                posCount++;
                avg += a;
            }
            if (b != -1.0f)
            {
                posCount++;
                avg += b;
            }
            if (c != -1.0f)
            {
                posCount++;
                avg += c;
            }
            if (d != -1.0f)
            {
                posCount++;
                avg += d;
            }

            if (posCount > 0)
            {
                return avg / posCount;
            }
            else
            {
                return 0.0f;
            }
        }

        for (int i = 0; i < chunkRes; i++)
        {
            for (int j = 0; j < chunkRes; j++)
            {
                tileValues[i, j] = -1.0f;
            }
        }
        
        float[] llcorner = { getValueFormChunks(x - 1, y),
                             getValueFormChunks(x, y-1),
                             getValueFormChunks(x - 1, y-1),
                             -1};

        float[] ulcorner = { getValueFormChunks(x, y + chunkRes),
                             getValueFormChunks(x-1, y + chunkRes),
                             getValueFormChunks(x-1, y + chunkRes - 1),
                             -1};

        float[] lrcorner = { getValueFormChunks(x + chunkRes, y),
                             getValueFormChunks(x + chunkRes, y - 1),
                             getValueFormChunks(x + chunkRes-1, y - 1),
                             -1 };

        float[] urcorner = { getValueFormChunks(x + chunkRes, y+chunkRes),
                             getValueFormChunks(x + chunkRes, y + chunkRes-1),
                             getValueFormChunks(x + chunkRes-1, y + chunkRes),
                             -1};


        tileValues[0, 0] = averageWithNull(llcorner[0], llcorner[1], llcorner[2], llcorner[3]);
        tileValues[chunkRes - 1, 0] = averageWithNull(ulcorner[0], ulcorner[1], ulcorner[2], ulcorner[3]); ;
        tileValues[0, chunkRes - 1] = averageWithNull(lrcorner[0], lrcorner[1], lrcorner[2], lrcorner[3]); ;
        tileValues[chunkRes - 1, chunkRes - 1] = averageWithNull(urcorner[0], urcorner[1], urcorner[2], urcorner[3]); ;


        while (squareSize>2)
        {
            float windowRatio = (float)squareSize / chunkRes;
            for(int i=0; i < chunkRes - 1;i+=squareSize-1)
            {
                for (int j=0; j < chunkRes - 1; j+=squareSize-1)
                {
                    
                    float displacement = Random.Range(-0.5f, 0.5f) * windowRatio * grain;

                    int centerX = (int)Mathf.Floor(i / 2 + (i + squareSize - 1) / 2);
                    int centerY = (int)Mathf.Floor(j / 2 + (j + squareSize - 1) / 2);

                    float tileValue = 0.0f;
                    
                    tileValue = averageWithNull(tileValues[i, j],
                        tileValues[i + squareSize - 1, j],
                        tileValues[i, j + squareSize - 1],
                        tileValues[i + squareSize - 1, j + squareSize - 1]) + displacement;

                    tileValue = Mathf.Clamp(tileValue,0.0f,1.0f);

                    tileValues[centerX, centerY] = tileValue;
                }

            }

            int halfsize = (int)Mathf.Floor((float)squareSize / 2);
            for (int i = 0; i <= chunkRes - 1; i += halfsize)
            {
                for (int j = (Mathf.Floor((float)i / halfsize) % 2 == 0 ? halfsize : 0); j <= chunkRes - 1; j += squareSize - 1)
                {
                    
                    // determine bounds of the square
                    int left = j - halfsize;
                    int right = j + halfsize;
                    int top = i + halfsize;
                    int bottom = i - halfsize;

                    // get the 4 required values.
                    float pLeft = getValueFormChunks(i, left);
                    float pRight = getValueFormChunks(i, right);
                    float pTop = getValueFormChunks(top, j);
                    float pBottom = getValueFormChunks(bottom, j);
                    // determine random factor

                    float displacement = Random.Range(-0.5f, 0.5f) * windowRatio * grain;

                    // determine resulting value by averaging the 4 points and adding the random factor
                    float value = averageWithNull(pLeft, pTop, pRight, pBottom)+displacement;

                    // clip the value if it falls outside [0,1]
                    value = Mathf.Clamp(value, 0.0f, 1.0f);

                    tileValues[i,j] = value;
                }

            }

            squareSize = (int)Mathf.Floor(squareSize/2)+1;
        }

        for(int i=0;i<chunkRes;i++)
        {
            for (int j = 0; j < chunkRes; j++)
            {
                Tile.TileType type = Tile.getTypeNormalized(tileValues[i, j]);
            }
        }

        Chunk newChunk = new Chunk(chunkRes, chunkRes, x, y);
        newChunk.map = new Map(tileValues);//add constructor for normalized values
        return newChunk;
    }

    public static void reassignBiomes(int x, int y, Dictionary<Tuple<int, int>, Chunk> chunks)
    {
        Chunk currentChunk;
        bool check = chunks.TryGetValue(new Tuple<int, int>(x, y), out currentChunk);

        if (!check)
            return;


        int chunkSize = currentChunk.map.Height;


        BiomeCenter getBiomeFormChunks(int a, int b)
        {
            if (a < 2 && b < 2 && b >= 0 && a >= 0)
                return currentChunk.Biomes[a, b];
            
            int xChunkOffset = 0;
            int yChunkOffset = 0;

            int chunkX = a;
            int chunkY = b;

            if (a > 1)
            {
                xChunkOffset = 1;
                chunkX = a - 2;
            }

            if (a < 0)
            {
                xChunkOffset = -1;
                chunkX = 2 + a;
            }

            if (b > 1)
            {
                yChunkOffset = 1;
                chunkY = b - 2;
            }

            if (b < 0)
            {
                yChunkOffset = -1;
                chunkY = 2 + b;
            }


            Chunk chunk;
            check = chunks.TryGetValue(new Tuple<int, int>(x + xChunkOffset, y + yChunkOffset), out chunk);

            if (check)
                return chunk.Biomes[chunkX, chunkY];    
            else
            {
                BiomeCenter result = new BiomeCenter();
                result.x = -1;
                result.y = -1;

                return result;
            }
        }
        
        int halfsize = Mathf.FloorToInt((float)chunkSize / 2);
        for (int i=0;i<chunkSize;i++)
        {
            for (int j = 0; j < chunkSize; j++)
            {
                int xQuadrant = 0, yQuadrant = 0;

                for (int bx = 0; bx < 2; bx++)
                {
                    for (int by = 0; by < 2; by++)
                    {
                        if (i >= (bx * halfsize) &&
                            i < ((bx + 1) * halfsize)+1  &&
                            j >= (by * halfsize) && 
                            j < ((by + 1) * halfsize) + 1)
                        {
                            xQuadrant = bx;
                            yQuadrant = by;
                        }
                    }
                }


                Tile currentTile = currentChunk.map.getTile(i,j);
                
                Tuple<int, int> tilePos = currentChunk.getTileWorldPos(i, j);

                Tile.BiomeType closestBiome = Tile.BiomeType.Tundra;

                float closestDist = float.PositiveInfinity;
                for (int bx = -1; bx < 2; bx++)
                {
                    for (int by = -1; by < 2; by++)
                    {
                        BiomeCenter b = getBiomeFormChunks(xQuadrant+bx, yQuadrant+by);

                        if (b.x == -1 && b.y == -1)
                            continue;

                        Tuple<int, int> biomePos = b.chunk.getTileWorldPos(b.x, b.y);

                        Vector2 dist = new Vector2(tilePos.Item1-biomePos.Item1, tilePos.Item2 - biomePos.Item2);
                        
                        if (closestDist>dist.magnitude)
                        {
                            closestDist = dist.magnitude;
                            closestBiome = b.biome;
                        }
                    }
                }
                
                currentTile.Biome = closestBiome;
            }
        }
    }

    public static void generatePlants(int x, int y, Dictionary<Tuple<int, int>, Chunk> chunks)
    {

        Chunk currentChunk;
        bool check = chunks.TryGetValue(new Tuple<int, int>(x, y), out currentChunk);

        if (!check)
            return;


        int chunkSize = currentChunk.map.Height;

        for (int i = 0; i < chunkSize; i++)
        {
            for (int j = 0; j < chunkSize; j++)
            {
                Tile tile = currentChunk.map.getTile(i,j);

                Plant plant = currentChunk.map.getPlant(i, j);
                plant.Biome = tile.Biome;
                if (tile.isEmpty() || !tile.isWalkable())
                    continue;
                Tuple<int,int> pos = currentChunk.getTileWorldPos(i, j);

                if (Mathf.PerlinNoise((float)pos.Item1/chunkSize, (float)pos.Item2 / chunkSize) < 0.5)
                    continue;

                if (tile.Biome == Tile.BiomeType.Tundra)
                {
                    if (!tile.isSand())
                        plant.Type = (Plant.PlantType)(Mathf.FloorToInt(Random.Range(1, 4)));

                } else if(tile.Biome == Tile.BiomeType.Ice || tile.Biome == Tile.BiomeType.Desert)
                        plant.Type = (Plant.PlantType)(Mathf.FloorToInt(Random.Range(1, 4)));
               
            }
        }
    }
}

